name: Deploy Backend

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/marconi-backend

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: password
          POSTGRES_DB: marconi_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgresql+asyncpg://postgres:password@localhost:5432/marconi_test
      SUPERADMIN_EMAILS: admin@example.com
      SUPERADMIN_PASSWORD: password123
      # Avoid external services during CI.
      REDIS_URL: ""
      JOBE_BASE_URL: http://localhost:4000
      JOBE_ALLOWED_LANGUAGES: c,cpp

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install uv
        run: python -m pip install --upgrade pip uv

      - name: Install dependencies
        working-directory: backend
        run: uv pip install --system -e ".[dev]"

      - name: Run tests
        working-directory: backend
        run: uv run pytest -q

  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-,format=long
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache,mode=max

  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy via SSH
        env:
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB != '' && secrets.POSTGRES_DB || 'marconi_elearn' }}
          SUPERADMIN_EMAILS: ${{ secrets.SUPERADMIN_EMAILS }}
          SUPERADMIN_PASSWORD: ${{ secrets.SUPERADMIN_PASSWORD }}
          CORS_ALLOW_ORIGINS: ${{ secrets.CORS_ALLOW_ORIGINS }}
          JOBE_BASE_URL: ${{ secrets.JOBE_BASE_URL }}
          JOBE_TIMEOUT_SECONDS: ${{ secrets.JOBE_TIMEOUT_SECONDS != '' && secrets.JOBE_TIMEOUT_SECONDS || '20' }}
          JOBE_ALLOWED_LANGUAGES: ${{ secrets.JOBE_ALLOWED_LANGUAGES != '' && secrets.JOBE_ALLOWED_LANGUAGES || 'c,cpp,python3,java' }}
          REDIS_URL: ${{ secrets.REDIS_URL != '' && secrets.REDIS_URL || 'redis://redis:6379/0' }}
          DOCKER_IMAGE: ${{ env.DOCKER_IMAGE }}
          DOCKER_TAG: main-${{ github.sha }}
          SESSION_COOKIE_SECURE: "true"
          SESSION_COOKIE_SAMESITE: "lax"
        run: |
          set -euo pipefail

          # Create .env locally on the runner without printing secrets.
          python - <<'PY'
          import os
          from pathlib import Path

          def get(name: str, default: str = "") -> str:
              value = os.environ.get(name)
              return value if value else default

          lines = [
              f"POSTGRES_USER={get('POSTGRES_USER')}",
              f"POSTGRES_PASSWORD={get('POSTGRES_PASSWORD')}",
              f"POSTGRES_DB={get('POSTGRES_DB','marconi_elearn')}",
              f"SUPERADMIN_EMAILS={get('SUPERADMIN_EMAILS')}",
              f"SUPERADMIN_PASSWORD={get('SUPERADMIN_PASSWORD')}",
              f"CORS_ALLOW_ORIGINS={get('CORS_ALLOW_ORIGINS')}",
              f"JOBE_BASE_URL={get('JOBE_BASE_URL')}",
              f"JOBE_TIMEOUT_SECONDS={get('JOBE_TIMEOUT_SECONDS','20')}",
              f"JOBE_ALLOWED_LANGUAGES={get('JOBE_ALLOWED_LANGUAGES','c,cpp,python3,java')}",
              f"REDIS_URL={get('REDIS_URL','redis://redis:6379/0')}",
              f"SESSION_COOKIE_SECURE={get('SESSION_COOKIE_SECURE','true')}",
              f"SESSION_COOKIE_SAMESITE={get('SESSION_COOKIE_SAMESITE','lax')}",
              f"DOCKER_IMAGE={get('DOCKER_IMAGE')}",
              f"DOCKER_TAG={get('DOCKER_TAG')}",
          ]

          Path(".env").write_text("\n".join(lines) + "\n", encoding="utf-8")
          PY

          # Ensure remote directory exists
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "mkdir -p ~/marconi"

          # Transfer files to server
          scp .env ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:~/marconi/.env
          scp backend/docker-compose.yml ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:~/marconi/docker-compose.yml

          # Execute remote deployment commands
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'ENDSSH'
            set -euo pipefail
            cd ~/marconi

            # Create external networks if they don't exist
            docker network inspect nginx-proxy-manager_npm-network >/dev/null 2>&1 || docker network create nginx-proxy-manager_npm-network 2>/dev/null || true
            docker network inspect proxy_hostinger-network >/dev/null 2>&1 || docker network create proxy_hostinger-network 2>/dev/null || true

            # Always stop the stack and remove orphans (best-effort).
            docker compose -p marconi -f docker-compose.yml down --remove-orphans || true

            # If older runs created fixed-name containers outside this compose project, remove them too.
            docker rm -f marconi-backend marconi-postgres marconi-redis >/dev/null 2>&1 || true

            docker compose -p marconi -f docker-compose.yml pull

            # Bring up dependencies first so we can ensure the DB exists.
            docker compose -p marconi -f docker-compose.yml up -d --force-recreate postgres redis

            # Wait for PostgreSQL to be ready.
            echo "Waiting for PostgreSQL..."
            for i in {1..30}; do
              if docker compose -p marconi -f docker-compose.yml exec -T postgres pg_isready -U "$POSTGRES_USER" >/dev/null 2>&1; then
                echo "PostgreSQL is ready!"
                break
              fi
              sleep 2
              if [ "$i" -eq 30 ]; then
                echo "Postgres did not become ready in time"
                docker compose -p marconi -f docker-compose.yml logs postgres
                exit 1
              fi
            done

            # Wait for Redis to be ready.
            echo "Waiting for Redis..."
            for i in {1..15}; do
              if docker compose -p marconi -f docker-compose.yml exec -T redis redis-cli ping | grep -q PONG; then
                echo "Redis is ready!"
                break
              fi
              sleep 2
              if [ "$i" -eq 15 ]; then
                echo "Redis did not become ready in time"
                docker compose -p marconi -f docker-compose.yml logs redis
                exit 1
              fi
            done

            if docker compose -p marconi -f docker-compose.yml exec -T postgres psql -U "$POSTGRES_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='${POSTGRES_DB}'" | grep -q 1; then
              echo "Database already exists: $POSTGRES_DB"
            else
              docker compose -p marconi -f docker-compose.yml exec -T postgres createdb -U "$POSTGRES_USER" "$POSTGRES_DB"
              echo "Database created: $POSTGRES_DB"
            fi

            docker compose -p marconi -f docker-compose.yml up -d --force-recreate backend

            echo "Waiting for backend health..."
            for i in {1..30}; do
              if docker compose -p marconi -f docker-compose.yml exec -T backend curl -fsS http://localhost:8000/ | grep -q '"status":"healthy"'; then
                echo "Backend is healthy!"
                break
              fi
              echo "Waiting... ($i/30)"
              sleep 10
              if [ $i -eq 30 ]; then
                echo "Timeout waiting for backend to be healthy"
                docker compose -p marconi -f docker-compose.yml logs backend
                exit 1
              fi
            done

            docker compose -p marconi -f docker-compose.yml exec -T backend python -m alembic upgrade head

            # Cleanup dangling images to prevent disk bloat.
            docker image prune -f --filter dangling=true >/dev/null 2>&1 || true

            docker compose -p marconi -f docker-compose.yml ps
            echo "Deployment complete!"
          ENDSSH
