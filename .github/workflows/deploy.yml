name: Deploy Backend

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/marconi-backend

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: password
          POSTGRES_DB: marconi_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgresql+asyncpg://postgres:password@localhost:5432/marconi_test
      SUPERADMIN_EMAILS: admin@example.com
      SUPERADMIN_PASSWORD: password123
      # Avoid external services during CI.
      REDIS_URL: ""
      JOBE_BASE_URL: http://localhost:4000
      JOBE_ALLOWED_LANGUAGES: c,cpp

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install uv
        run: python -m pip install --upgrade pip uv

      - name: Install dependencies
        working-directory: backend
        run: uv pip install --system -e ".[dev]"

      - name: Run tests
        working-directory: backend
        run: uv run pytest -q

  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-,format=long
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: backend/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_IMAGE }}:buildcache,mode=max

  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy via SSH
        env:
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB != '' && secrets.POSTGRES_DB || 'marconi_elearn' }}
          SUPERADMIN_EMAILS: ${{ secrets.SUPERADMIN_EMAILS }}
          SUPERADMIN_PASSWORD: ${{ secrets.SUPERADMIN_PASSWORD }}
          CORS_ALLOW_ORIGINS: ${{ secrets.CORS_ALLOW_ORIGINS }}
          JOBE_BASE_URL: ${{ secrets.JOBE_BASE_URL }}
          JOBE_TIMEOUT_SECONDS: ${{ secrets.JOBE_TIMEOUT_SECONDS != '' && secrets.JOBE_TIMEOUT_SECONDS || '20' }}
          JOBE_ALLOWED_LANGUAGES: ${{ secrets.JOBE_ALLOWED_LANGUAGES != '' && secrets.JOBE_ALLOWED_LANGUAGES || 'c,cpp,python3,java' }}
          JOBE_API_KEY: ${{ secrets.JOBE_API_KEY }}
          REDIS_URL: ${{ secrets.REDIS_URL != '' && secrets.REDIS_URL || 'redis://redis:6379/0' }}
          TOKEN_ENCRYPTION_KEY: ${{ secrets.TOKEN_ENCRYPTION_KEY }}
          DOCKER_IMAGE: ${{ env.DOCKER_IMAGE }}
          DOCKER_TAG: main-${{ github.sha }}
          SESSION_COOKIE_SECURE: "true"
          SESSION_COOKIE_SAMESITE: "lax"
        run: |
          set -euo pipefail

          # Create .env locally on the runner without printing secrets.
          python - <<'PY'
          import os
          from pathlib import Path

          def get(name: str, default: str = "") -> str:
              value = os.environ.get(name)
              return value if value else default

          if not get("TOKEN_ENCRYPTION_KEY"):
              raise SystemExit("Missing TOKEN_ENCRYPTION_KEY in GitHub Secrets")

          lines = [
              f"POSTGRES_USER={get('POSTGRES_USER')}",
              f"POSTGRES_PASSWORD={get('POSTGRES_PASSWORD')}",
              f"POSTGRES_DB={get('POSTGRES_DB','marconi_elearn')}",
              f"SUPERADMIN_EMAILS={get('SUPERADMIN_EMAILS')}",
              f"SUPERADMIN_PASSWORD={get('SUPERADMIN_PASSWORD')}",
              f"CORS_ALLOW_ORIGINS={get('CORS_ALLOW_ORIGINS')}",
              f"JOBE_BASE_URL={get('JOBE_BASE_URL')}",
              f"JOBE_TIMEOUT_SECONDS={get('JOBE_TIMEOUT_SECONDS','20')}",
              f"JOBE_ALLOWED_LANGUAGES={get('JOBE_ALLOWED_LANGUAGES','c,cpp,python3,java')}",
              f"JOBE_API_KEY={get('JOBE_API_KEY')}",
              f"REDIS_URL={get('REDIS_URL','redis://redis:6379/0')}",
              f"SESSION_COOKIE_NAME={get('SESSION_COOKIE_NAME','marconi_session')}",
              f"SESSION_COOKIE_SECURE={get('SESSION_COOKIE_SECURE','true')}",
              f"SESSION_COOKIE_SAMESITE={get('SESSION_COOKIE_SAMESITE','lax')}",
              f"TOKEN_ENCRYPTION_KEY={get('TOKEN_ENCRYPTION_KEY')}",
              f"GITHUB_APP_CLIENT_ID={get('GITHUB_APP_CLIENT_ID')}",
              f"GITHUB_APP_CLIENT_SECRET={get('GITHUB_APP_CLIENT_SECRET')}",
              f"GITHUB_APP_OAUTH_REDIRECT_URL={get('GITHUB_APP_OAUTH_REDIRECT_URL')}",
              f"DOCKER_IMAGE={get('DOCKER_IMAGE')}",
              f"DOCKER_TAG={get('DOCKER_TAG')}",
              f"BACKEND_PORT={get('BACKEND_PORT','32316')}",
          ]

          Path(".env").write_text("\n".join(lines) + "\n", encoding="utf-8")
          PY

          # Ensure remote directory exists
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "mkdir -p ~/marconi"

          # Transfer files to server
          scp .env ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:~/marconi/.env
          scp backend/docker-compose.yml ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:~/marconi/docker-compose.yml

          # Execute remote deployment commands
          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'ENDSSH'
            set -euo pipefail
            cd ~/marconi

            # Create external networks if they don't exist
            docker network inspect nginx-proxy-manager_npm-network >/dev/null 2>&1 || docker network create nginx-proxy-manager_npm-network 2>/dev/null || true
            docker network inspect proxy_hostinger-network >/dev/null 2>&1 || docker network create proxy_hostinger-network 2>/dev/null || true

            # Always stop the stack and remove orphans (best-effort).
            docker compose -p marconi -f docker-compose.yml down --remove-orphans || true

            # If older runs created fixed-name containers outside this compose project, remove them too.
            docker rm -f marconi-backend marconi-worker marconi-deadline-poller marconi-postgres marconi-redis marconi-jobe >/dev/null 2>&1 || true

            # Defensive: ensure conflicting fixed-name containers are gone before `up`.
            for name in marconi-backend marconi-worker marconi-deadline-poller marconi-postgres marconi-redis marconi-jobe; do
              for i in {1..10}; do
                if docker ps -a --format '{{.Names}}' | grep -qx "$name"; then
                  docker rm -f "$name" >/dev/null 2>&1 || true
                  sleep 1
                else
                  break
                fi
              done
              if docker ps -a --format '{{.Names}}' | grep -qx "$name"; then
                echo "Conflicting container still exists: $name"
                docker ps -a --filter "name=^/${name}$" || true
                exit 1
              fi
            done

            docker compose -p marconi -f docker-compose.yml pull

            # Bring up all services - depends_on with service_healthy handles ordering
            docker compose -p marconi -f docker-compose.yml up -d --force-recreate

            # Extract values from .env file for DB creation check
            set +u  # Allow unbound variables temporarily
            . ./.env
            POSTGRES_USER="${POSTGRES_USER:-postgres}"
            POSTGRES_DB="${POSTGRES_DB:-marconi_elearn}"
            set -u

            if ! [[ "$POSTGRES_USER" =~ ^[A-Za-z0-9_]+$ ]]; then
              echo "Invalid POSTGRES_USER in .env: $POSTGRES_USER"
              exit 1
            fi
            if ! [[ "$POSTGRES_DB" =~ ^[A-Za-z0-9_]+$ ]]; then
              echo "Invalid POSTGRES_DB in .env: $POSTGRES_DB"
              exit 1
            fi

            # Wait for postgres to be healthy before checking DB
            echo "Waiting for PostgreSQL to be healthy..."
            for i in {1..30}; do
              status=$(docker inspect --format='{{.State.Health.Status}}' marconi-postgres 2>/dev/null || echo "starting")
              if [ "$status" = "healthy" ]; then
                echo "PostgreSQL is ready!"
                break
              fi
              sleep 2
              if [ "$i" -eq 30 ]; then
                echo "Postgres did not become healthy in time"
                docker logs marconi-postgres
                exit 1
              fi
            done

            if docker compose -p marconi -f docker-compose.yml exec -T postgres psql -U "$POSTGRES_USER" -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='${POSTGRES_DB}'" | grep -q 1; then
              echo "Database already exists: $POSTGRES_DB"
            else
              docker compose -p marconi -f docker-compose.yml exec -T postgres createdb -U "$POSTGRES_USER" "$POSTGRES_DB"
              echo "Database created: $POSTGRES_DB"
            fi

            # Wait for backend health (migrations run automatically via start.sh)
            echo "Waiting for backend health..."
            for i in {1..60}; do
              if docker compose -p marconi -f docker-compose.yml exec -T backend curl -fsS http://localhost:8000/ >/dev/null 2>&1; then
                echo "Backend is healthy!"
                BACKEND_HOST=$(hostname -I | awk '{print $1}')
                echo "Backend reachable on http://${BACKEND_HOST}:${BACKEND_PORT:-32316}"
                break
              fi
              echo "Waiting... ($i/60)"
              sleep 5
              if [ $i -eq 60 ]; then
                echo "Timeout waiting for backend to be healthy"
                docker compose -p marconi -f docker-compose.yml logs backend
                exit 1
              fi
            done

            # Verify backend -> JOBE connectivity from inside backend container.
            echo "Verifying JOBE connectivity from backend..."
            docker compose -p marconi -f docker-compose.yml exec -T backend python - <<'PY'
            import asyncio
            from app.core.config import settings
            from app.integrations.jobe import JobeClient

            async def main() -> None:
                client = JobeClient(
                    base_url=settings.jobe_base_url,
                    timeout_seconds=settings.jobe_timeout_seconds,
                    api_key=settings.jobe_api_key,
                )
                languages = await client.list_languages()
                print(f"JOBE connectivity verified. languages={len(languages)}")

            asyncio.run(main())
            PY

            # Cleanup dangling images to prevent disk bloat.
            docker image prune -f --filter dangling=true >/dev/null 2>&1 || true

            docker compose -p marconi -f docker-compose.yml ps
            echo "Deployment complete!"
            exit 0
          ENDSSH
